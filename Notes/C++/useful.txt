//
int to string: to_string
long long to string: to_string
float to string: to_string
double to string: to_string

string to int: stoi
string to long long: stoll
string to float: stof
string to double: stod

Ex.
    string s="12KYL";
    size_t idx;
    int n=stoi(s, &idx);
    cout<<n<<"\n"; // 12
    cout<<idx; // 2

// accumulate
int sum(accumulate(v.begin(), v.end(), 0));
int product(accumulate(v.begin(), v.end(), 1, multiplies<int>()));
int _(accumulate(v.begin(), v.end(), 0, minus<int>()));
int _(accumulate(v.begin(), v.end(), 0, [](int x, iny y){
    return x-y;
}));

// 0b(2), 0(8), 0x(16)
// 0-based index vs 1-based index
// ++i vs i++
// start&finish vs begin&end vs front&back
// lvalue(locator value, left(-hand) value) vs rvalue(right(-hand) value)
// auto vs decltype
// previous>current>next

//
#define INT_MAX 2147483647 // = 2^31-1 > 2*10^9
#define INT_MIN -2147483648
#define LLONG_MAX 9223372036854775807LL // = 2^63-1 > 9*10^18
#define LLONG_MIN -9223372036854775807LL-1LL

// unique
vector<int> v({1, 3, 1, 1, 1, 2, 3, 2, 2, 2});
unique(v.begin(), v.end())
v.erase(unique(v.begin(), v.end()), v.end());

//
vector<int> v(N);
iota(v.begin(), v.end(), val);

vector<int> v(10);
iota(v.begin(), v.end(), 0);

// pos ~~ index vs iterator

//
lower_bound(vec.begin(), vec.end(), target)-vec.begin();
upper_bound(vec.begin(), vec.end(), target)-vec.begin();

// structured binding(s)
auto [c, d]={a, b};

pair<int, int> p{a, b};
auto& [c, d]=p;
const auto& [c, d]=p;

map<string, int> m;
for(auto& [k, v]: m){
    ;
}

//
void f(int a)
    pass-by-value
    int, long long, double, ...

void f(int& a)
    pass-by-reference
    only lvalue

void f(const int a)
    not usually used

void f(const int& a)
    both rvalue and lvalue
    string, vector, map, ...

//
vector<int> v;
max_element(v.begin(), v.end())
*max_element(v.begin(), v.end())
min_element(v.begin(), v.end())
*min_element(v.begin(), v.end())

bool cmp(const int& x, const int& y){
    return abs(x)<abs(y);
}
max_element(v.begin(), v.end(), cmp)

//
'\n'
"\n"={'\n', '\0'}
"\n"[0]
"\n"[1]

cout<<'A'<<'\n'<<'A';
cout<<'B'<<"\n"[0]<<'B';
cout<<'C'<<"\n"[1]<<'C';
cout<<'D'<<"\n"<<'D';

//
floor((x+y-1)/y)=ceil(x/y)
floor((x-1)/y+1)=ceil(x/y)

//
vector<int> v;
sort(v.begin(), v.end(), greater<int>());

sort(v.begin(), v.end(), [](int x, int y){
    return x>y;
});

sort(v.begin(), v.end());
reverse(v.begin(), v.end());

//
vector<int> v{0, 1, 2, 3, 4};

swap(v[1], v[3]);
iter_swap(v.begin()+1, v.begin()+3);

//
vector<int> v{0, 1, 2, 3, 4};
vector<int> w{5, 6, 7, 8, 9};

v.swap(w);

// Block Scope
{
    int x(10);
    {
        int x(20);
        cout<<x<<'\n'; // 20
    }
    cout<<x<<'\n'; // 10
}

// Name Shadowing(=Hiding)
{
    int N(10);
    void f(){
        cout<<N<<'\n'; // 10

        int N(20);
        cout<<N<<'\n'; // 20
    }
}

{
    int N(10);
    
    void f(int N){
        cout<<N<<'\n'; // f(5)=>5
    }
}

{
    int N(10);

    void f(){
        {
            int N(20);
            cout<<N<<'\n'; // 20
        }
        cout<<N<<'\n'; // 10
    }
}

{
    int N(10);

    void f(){
        int N(20);
        cout<<N<<'\n'; // 20
        cout<<::N<<"\n'; // 10
    }
}

//
sort ~~ object (instance), (function)
priority_queue ~~ type

//
stable_sort

//
double x; double y;

y=round(x); y=round(x*10)/10; y=double(x*100)/100;
y=int(x*10+0.5)/10;

y=round(x);
y=ceil(x);
y=floor(x);
y=trunc(x);